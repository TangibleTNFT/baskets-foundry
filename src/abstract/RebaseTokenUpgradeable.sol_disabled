// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

import { ERC20Upgradeable } from "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import { RebaseTokenMath } from "../libraries/RebaseTokenMath.sol";

error AmountExceedsBalance(address account, uint256 balance, uint256 amount);

abstract contract RebaseTokenUpgradeable is ERC20Upgradeable {
    using RebaseTokenMath for uint256;

    /// @custom:storage-location erc7201:tangible.storage.RebaseToken
    struct RebaseTokenStorage {
        uint256 rebaseIndex;
        uint256 totalShares;
        mapping(address => uint256) shares;
    }

    // keccak256(abi.encode(uint256(keccak256("tangible.storage.RebaseToken")) - 1)) & ~bytes32(uint256(0xff))
    bytes32 private constant RebaseTokenStorageLocation =
        0x8a0c9d8ec1d9f8b365393c36404b40a33f47675e34246a2e186fbefd5ecd3b00;

    function _getRebaseTokenStorage() private pure returns (RebaseTokenStorage storage $) {
        assembly {
            $.slot := RebaseTokenStorageLocation
        }
    }

    event RebaseIndexUpdated(address updatedBy, uint256 index);

    function __RebaseToken_init(string memory name, string memory symbol) internal onlyInitializing {
        __RebaseToken_init_unchained();
        __ERC20_init(name, symbol);
    }

    function __RebaseToken_init_unchained() internal onlyInitializing {}

    function _setRebaseIndex(uint256 index) internal virtual {
        RebaseTokenStorage storage $ = _getRebaseTokenStorage();
        if ($.rebaseIndex != index) {
            $.rebaseIndex = index;
            _checkRebaseOverflow($.totalShares, index);
            emit RebaseIndexUpdated(msg.sender, index);
        }
    }

    function _transferableShares(uint256 amount, address from) internal view returns (uint256 shares) {
        RebaseTokenStorage storage $ = _getRebaseTokenStorage();
        shares = $.shares[from];
        uint index = $.rebaseIndex;
        uint256 balance = shares.toTokens(index);
        if (amount > balance) {
            revert AmountExceedsBalance(from, balance, amount);
        }
        if (amount < balance) {
            shares = amount.toShares(index);
        }
    }

    function rebaseIndex() public view returns (uint256 index) {
        RebaseTokenStorage storage $ = _getRebaseTokenStorage();
        return $.rebaseIndex;
    }

    function totalSupply() public view override returns (uint256) {
        RebaseTokenStorage storage $ = _getRebaseTokenStorage();
        return $.totalShares.toTokens($.rebaseIndex);
    }

    function balanceOf(address account) public view override returns (uint256 balance) {
        RebaseTokenStorage storage $ = _getRebaseTokenStorage();
        balance = $.shares[account].toTokens($.rebaseIndex);
    }

    function _update(address from, address to, uint256 value) internal override {
        RebaseTokenStorage storage $ = _getRebaseTokenStorage();
        uint256 index = $.rebaseIndex;
        uint256 shares = value.toShares($.rebaseIndex);
        if (from == address(0)) {
            uint256 totalShares = $.totalShares + shares; // Overflow check required
            _checkRebaseOverflow(totalShares, index);
            $.totalShares = totalShares;
        } else {
            shares = _transferableShares(value, from);
            unchecked {
                // Underflow not possible: shares <= $.shares[from] <= totalShares.
                $.shares[from] -= shares;
            }
        }

        if (to == address(0)) {
            unchecked {
                // Overflow not possible: shares <= $.totalShares or shares <= $.shares[from] <= $.totalShares.
                $.totalShares -= shares;
            }
        } else {
            unchecked {
                // Overflow not possible: $.shares[to] + shares is at most $.totalShares, which we know fits into a uint256.
                $.shares[to] += shares;
            }
        }

        emit Transfer(from, to, value);
    }

    function _checkRebaseOverflow(uint256 shares, uint256 index) private pure {
        // This condition inside `assert()` can never evaluate `false`, but `toTokens()` would throw an arithmetic exception
        // in case we overflow, and that's all we need.
        assert(shares.toTokens(index) <= type(uint256).max);
    }
}
